generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  // https://github.com/prisma/prisma/issues/11789#issuecomment-1900773221
  url      = env("DATABASE_URL")
}

model User {
  id       Int     @id @unique @default(autoincrement())
  username String  @unique
  password String
  token    String? @unique
  items    Item[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// E.g. "Electronics", "DIY", "Clothes", "Shoes", ...
// Every class in ML model should be assigned to an inventory
model Inventory {
  id          Int    @id @unique @default(autoincrement())
  name        String
  description String
  classes     String // NOTE: JSON array, E.g. [ shoes, clothes, *, O, R]
  items       Item[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Item {
  id          Int       @id @unique @default(autoincrement())
  slug        String
  amount      Int?
  title       String?
  description String?
  reason      String?
  // TODO: Inventory _can_ be determined by ML model classification (running on Jetson)
  inventory   Inventory? @relation(fields: [inventoryId], references: [id])
  inventoryId Int?

  author   User @relation(fields: [authorId], references: [id])
  authorId Int

  photos     Photo[]
  documents  Document[]
  tags       Tag[]
  locations  Container[]
  attributes KVP[] // e.g. width, height, color (should override colors of photo, I guess), etc
  usage      InUse[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Photo {
  id              Int     @id @unique @default(autoincrement())
  type            String  @default("item")
  orgPath         String?
  cropPath        String?
  thumbPath       String?
  ocr             String?
  colors          String? // NOTE: JSON array

  classBlip       String? // NOTE: JSON
  classTrash      String? // NOTE: JSON

  item            Item @relation(fields: [itemId], references: [id])
  itemId          Int

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model Document {
  id       Int     @id @unique @default(autoincrement())
  type     String? // E.g. invoice, information, product-page, ...
  title    String
  source   String // AKA url
  path     String
  extracts String // AKA extracts

  item   Item @relation(fields: [itemId], references: [id])
  itemId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Container {
  id       Int         @id @unique @default(autoincrement())
  parentId Int?        @unique
  parent   Container?  @relation("ParentRelation", fields: [parentId], references: [id])
  children Container[] @relation("ParentRelation")

  // Ponder: A or A.001 ??? How fine-grained? How important is it to have a hierarchy?
  name        String @unique    // A or A.001 (Note: sub-containers must be denoted with period)
  description String            // closet with door
  location    String?           // top of desk (JR)
  photoPath   String?

  item   Item @relation(fields: [itemId], references: [id])
  itemId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model KVP {
  id    Int    @id @unique @default(autoincrement())
  key   String
  value String

  item   Item @relation(fields: [itemId], references: [id])
  itemId Int
}

model Tag {
  id    Int    @id @unique @default(autoincrement())
  name  String @unique
  slug  String @unique
  items Item[]
}

// Be able to tag items that are in use by/on something
model InUse {
  id          Int     @id @unique @default(autoincrement())
  title       String? // e.g. By VidensiVision
  description String? // e.g. ...mounted in shed to check presence of Ery

  item   Item @relation(fields: [itemId], references: [id])
  itemId Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
